"""Knowledge base for vulnerable function signatures."""

import json
import re
from dataclasses import dataclass
from pathlib import Path

from blastauri.core.models import Ecosystem


@dataclass
class VulnerabilitySignature:
    """Represents a vulnerability signature with affected functions."""

    cve_id: str
    package_name: str
    ecosystem: str
    vulnerable_version_range: str
    vulnerable_symbols: list[str]


def parse_version(version: str) -> tuple[int, ...]:
    """Parse a version string into a tuple for comparison.

    Args:
        version: Version string like "1.2.3", "2.0-beta9", "5.4"

    Returns:
        Tuple of integers for comparison (e.g., (1, 2, 3))
    """
    # Remove common pre-release suffixes for basic comparison
    version = re.sub(r'[-_](alpha|beta|rc|dev|pre|post)\.?\d*', '', version, flags=re.IGNORECASE)
    # Extract only the numeric parts
    parts = re.findall(r'\d+', version)
    return tuple(int(p) for p in parts) if parts else (0,)


def version_in_range(version: str, version_range: str) -> bool:
    """Check if a version falls within a vulnerability range.

    Args:
        version: The package version to check (e.g., "1.2.3")
        version_range: Range specification (e.g., "<2.0", ">=1.0,<2.0")

    Returns:
        True if the version is within the vulnerable range.
    """
    if not version or not version_range:
        return False

    try:
        ver = parse_version(version)
    except (ValueError, TypeError):
        return False

    # Split on comma for compound ranges (e.g., ">=2.0,<3.0")
    conditions = [c.strip() for c in version_range.split(',')]

    for condition in conditions:
        condition = condition.strip()
        if not condition:
            continue

        # Handle different operators
        if condition.startswith('>='):
            target = parse_version(condition[2:])
            if not (ver >= target):
                return False
        elif condition.startswith('<='):
            target = parse_version(condition[2:])
            if not (ver <= target):
                return False
        elif condition.startswith('>'):
            target = parse_version(condition[1:])
            if not (ver > target):
                return False
        elif condition.startswith('<'):
            target = parse_version(condition[1:])
            if not (ver < target):
                return False
        elif condition.startswith('=') or condition.startswith('=='):
            target = parse_version(condition.lstrip('='))
            if not (ver == target):
                return False
        elif condition.startswith('!='):
            target = parse_version(condition[2:])
            if ver == target:
                return False
        else:
            # Treat as exact version match
            target = parse_version(condition)
            if not (ver == target):
                return False

    return True


class VulnerabilityKB:
    """Knowledge base for looking up vulnerable functions."""

    def __init__(self, data_path: Path | None = None):
        """Initialize the KB.

        Args:
            data_path: Path to the JSON database file.
                       Defaults to built-in 'src/blastauri/data/vulnerable_functions.json'.
        """
        if data_path:
            self.data_path = data_path
        else:
            # Default location relative to this file
            self.data_path = Path(__file__).parent.parent / "data" / "vulnerable_functions.json"

        self.signatures: list[VulnerabilitySignature] = []
        self._load_data()

    def _load_data(self) -> None:
        """Load data from the JSON file."""
        if not self.data_path.exists():
            return

        try:
            with open(self.data_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                for item in data:
                    self.signatures.append(
                        VulnerabilitySignature(
                            cve_id=item["cve_id"],
                            package_name=item["package_name"],
                            ecosystem=item["ecosystem"],
                            vulnerable_version_range=item["vulnerable_version_range"],
                            vulnerable_symbols=item["vulnerable_symbols"],
                        )
                    )
        except Exception as e:
            # In a real app, we might log a warning here
            print(f"Warning: Failed to load vulnerability KB: {e}")

    def get_signatures_for_package(
        self,
        package_name: str,
        ecosystem: Ecosystem,
        version: str | None = None,
    ) -> list[VulnerabilitySignature]:
        """Get all signatures associated with a package.

        Args:
            package_name: Name of the package
            ecosystem: Ecosystem enum (e.g. Ecosystem.PYPI)
            version: Optional version to filter by vulnerability range

        Returns:
            List of matching signatures.
        """
        # Convert enum value to string for comparison (e.g. 'pypi')
        eco_str = ecosystem.value

        matching = [
            sig
            for sig in self.signatures
            if sig.package_name.lower() == package_name.lower() and sig.ecosystem.lower() == eco_str
        ]

        # If version provided, filter to only signatures that affect this version
        if version:
            matching = [
                sig
                for sig in matching
                if version_in_range(version, sig.vulnerable_version_range)
            ]

        return matching

    def is_version_vulnerable(
        self,
        package_name: str,
        ecosystem: Ecosystem,
        version: str,
    ) -> list[VulnerabilitySignature]:
        """Check if a specific package version is vulnerable.

        Args:
            package_name: Name of the package
            ecosystem: Ecosystem enum
            version: Version to check

        Returns:
            List of signatures that affect this version.
        """
        return self.get_signatures_for_package(package_name, ecosystem, version)
